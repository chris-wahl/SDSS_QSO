from typing import List, Union


def namestring_dict_writer( output_dict: dict, path: str, filename: str, top_key: str = "namestring",
                            sub_keys: List[ str ] = None ) -> None:
    """
    Writes a  dictionary of:

    [ namestring : sub_dictionary ]  or [ namestring : list ] or [ namestring : value ]

    to the disk as a CSV.  top_key will be written as the first column.

    If the values of the output_dict are dict themselves, the column names will be generated by the sub_dict's keys.  If sub_keys is passed, this will
    be overriden.  Can be used for selecting values from each sub_dict, if desired.

    If the values are given as a list or single value and sub_keys list is not passed, no column header will be given.

    If the values of output_dict are singular, then they will be written by their str( value ) form.  Similarly, if sub_keys is not passed, none will be written.

    Note: Only checks one entry to the output_dict value's format.  Thus, the output_dict values are expected to all be of the same format.

    :param output_dict: namestring dictionary to write
    :param path: /path/to/write/to
    :param filename: filename.csv
    :param top_key: The title to give the top_key.  Defaults to 'namestring'.  Will be the first column written.
    :param sub_keys: A list of sub_keys to title the columns if in_dict is passed as a list
    :return:
    """
    from fileio.utils import dirCheck, join
    from common.constants import os

    dirCheck( path )
    namekeys = list( output_dict.keys( ) )
    if type( output_dict[ namekeys[ 0 ] ] ) == dict:
        sub_keys = sorted(
                [ f"{sub_key}" for sub_key in output_dict[ namekeys[ 0 ] ].keys( ) ] ) if sub_keys is None else sub_keys
        sub_string = lambda x: ''.join( [ f"{x[ k ]}," for k in sub_keys ] )[ :-1 ] + os.linesep
    elif type( output_dict[ namekeys[ 0 ] ] ) == list:

        sub_string = lambda x: ''.join( f'{item},' for item in x )[ :-1 ] + os.linesep
    else:
        sub_string = lambda x: f"{x}{os.linesep}"

    with open( join( path, filename ), 'w' ) as outfile:
        if sub_keys is not None:
            outfile.write( f'{top_key},' + ''.join( [ f"{sk}," for sk in sub_keys ] )[ :-1 ] + os.linesep )
        outfile.writelines( f"{key},{sub_string( output_dict[ key ] )}" for key in namekeys )


def namestring_dict_reader( path: str, filename: str, top_key: str = "namestring", has_header: bool = True ) -> dict:
    from fileio.utils import fileCheck, join
    fileCheck( path, filename )

    def num_conv( num: str ) -> Union[ float, int ]:
        try:
            num = int( num )
        except ValueError:
            try:
                num = float( num )
            except ValueError:
                pass
        return num

    def form_dict( line: dict ) -> dict:
        namestring = line.pop( top_key )
        for k, v in line.items( ):
            line[ k ] = num_conv( v )
        return { namestring: dict( line ) }

    def form_list_value( line: str ) -> dict:
        line = line.strip( ).split( ',' )
        if (len( line ) > 2):
            for i in range( 1, len( line ) ):
                line[ i ] = num_conv( line[ i ] )
            return { line[ 0 ]: line[ 1: ] }

        line[ 1 ] = num_conv( line[ 1 ] )
        return { line[ 0 ]: line[ 1 ] }

    with open( join( path, filename ), 'r' ) as infile:
        outdict = { }
        reader = infile

        reader_func = None
        if (has_header):
            from csv import DictReader
            reader = DictReader( infile, fieldnames=infile.readline( ).strip( ).split( ',' ) )
            reader_func = form_dict
        else:
            reader_func = form_list_value

        for line in reader:
            outdict.update( reader_func( line ) )

    return outdict
