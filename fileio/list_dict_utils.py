from typing import List, Union


def namestring_dict_writer( output_dict: dict, path: str, filename: str, top_key: str = "namestring",
                            sub_keys: List[ str ] = None ) -> None:
    """
    Writes a  dictionary of:

    [ namestring : sub_dictionary ]  or [ namestring : list ] or [ namestring : value ]

    to the disk as a CSV.  top_key will be written as the first column.

    If the values of the output_dict are dict themselves, the column names will be generated by the sub_dict's keys.  If sub_keys is passed, this will
    be overriden.  Can be used for selecting values from each sub_dict, if desired.

    If the values are given as a list or single value and sub_keys list is not passed, no column header will be given.

    If the values of output_dict are singular, then they will be written by their str( value ) form.  Similarly, if sub_keys is not passed, none will be written.

    Note: Only checks one entry to the output_dict value's format.  Thus, the output_dict values are expected to all be of the same format.

    :param output_dict: namestring dictionary to write
    :param path: /path/to/write/to
    :param filename: filename.csv
    :param top_key: The title to give the top_key.  Defaults to 'namestring'.  Will be the first column written.
    :param sub_keys: A list of sub_keys to title the columns if in_dict is passed as a list
    :return:
    """
    from fileio.utils import dirCheck, join
    from common.constants import os

    dirCheck( path )
    namekeys = list( output_dict.keys( ) )
    if type( output_dict[ namekeys[ 0 ] ] ) == dict:
        sub_keys = sorted(
                [ f"{sub_key}" for sub_key in output_dict[ namekeys[ 0 ] ].keys( ) ] ) if sub_keys is None else sub_keys
        sub_string = lambda x: ''.join( [ f"{x[ k ]}," for k in sub_keys ] )[ :-1 ] + os.linesep
    elif type( output_dict[ namekeys[ 0 ] ] ) == list:

        sub_string = lambda x: ''.join( f'{item},' for item in x )[ :-1 ] + os.linesep
    else:
        sub_string = lambda x: f"{x}{os.linesep}"

    with open( join( path, filename ), 'w' ) as outfile:
        if sub_keys is not None:
            outfile.write( f'{top_key},' + ''.join( [ f"{sk}," for sk in sub_keys ] )[ :-1 ] + os.linesep )
        outfile.writelines( f"{key},{sub_string( output_dict[ key ] )}" for key in namekeys )


def namestring_dict_reader( path: str, filename: str, top_key: str = "namestring", has_header: bool = True ) -> dict:
    from fileio.utils import fileCheck, join
    fileCheck( path, filename )

    def num_conv( num: str ) -> Union[ float, int ]:
        try:
            num = int( num )
        except ValueError:
            try:
                num = float( num )
            except ValueError:
                pass
        return num

    def form_dict( line: dict ) -> dict:
        namestring = line.pop( top_key )
        for k, v in line.items( ):
            line[ k ] = num_conv( v )
        return { namestring: dict( line ) }

    def form_list_value( line: str ) -> dict:
        line = line.strip( ).split( ',' )
        if (len( line ) > 2):
            for i in range( 1, len( line ) ):
                line[ i ] = num_conv( line[ i ] )
            return { line[ 0 ]: line[ 1: ] }

        line[ 1 ] = num_conv( line[ 1 ] )
        return { line[ 0 ]: line[ 1 ] }

    with open( join( path, filename ), 'r' ) as infile:
        outdict = { }
        reader = infile

        reader_func = None
        if (has_header):
            from csv import DictReader
            reader = DictReader( infile, fieldnames=infile.readline( ).strip( ).split( ',' ) )
            reader_func = form_dict
        else:
            reader_func = form_list_value

        for line in reader:
            outdict.update( reader_func( line ) )

    return outdict


def simple_list_reader( path: str, filename: str, valuespliter: Union[ str, None ] = "," ) -> list:
    """
    Reads in a simple list from a file.  Will attempt to split each line by valuesplitter variable.
    Is capable of discerning between input types of int, float and str.  Will evaluate to these types accordingly.

    If the length of line.split( valuesplitter ) == 1, returns a simple list of values.  If that length is greater than one,
    the entry will be a tuple of all the individual values.

    :param path: /path/to/filename
    :param filename: name of the file
    :param valuespliter: value to split the line by.  Defaults to a comma ","  If you need to ensure the line is NOT split, enter valuesplitter = None
    :type path: str
    :type filename: str
    :type valuespliter: str or NoneType
    :return: List of file lines
    :rtype: list
    """
    from fileio.utils import fileCheck, join

    # Use this method to determine subtypes and assign accordingly
    # i.e. firgure out if it's an int, float, or string
    # If it can't make value one of those three terms, it throws an error
    def __get_type( value ) -> type:
        types = [ int, float, str ]
        for t in types:
            try:
                t( value )
                return t
            except ValueError:
                continue
        raise ValueError( f"Unable to determine type if input value: { value }" )

    fileCheck( path, filename )
    outlist = [ ]
    with open( join( path, filename ), 'r' ) as infile:
        for line in infile:
            line = line.strip( ).split( valuespliter )
            for i in range( len( line ) ):
                line[ i ] = __get_type( line[ i ].strip( ) )( line[ i ] )
            if len( line ) == 1:
                line = line[ 0 ]
            else:
                line = tuple( line )
            outlist.append( line )
    return outlist
